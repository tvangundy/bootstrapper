name: 'Integration Test'
description: 'Runs integration tests against Windsor CLI'

inputs:
  windsor_up:
    description: 'Whether to run Windsor Up before tests (true/false)'
    required: false
    type: boolean
    default: false
  version:
    description: 'Version in semantic format (e.g., v1.0.0)'
    required: false
    default: ''
  release_branch:
    description: 'Release branch name (e.g., release-1.0.0, release-latest)'
    required: false
    default: ''
  release_number:
    description: 'Release number (e.g., 1.0.0)'
    required: false
    default: ''
  windsor_test_config:
    description: 'Windsor test configuration file'
    required: false
    default: 'tests/configs/ci-integration-tests.yaml'
  docker_host:
    description: 'Docker host address for remote Docker operations'
    required: false
    default: ''
  platform:
    description: 'Platform OS (e.g., linux, windows)'
    required: false
    default: 'linux'

outputs:
  test_status:
    description: 'Status of the integration tests (success/failure)'
    value: ${{ steps.test_results.outputs.status }}

permissions:
  contents: read

runs:
  using: 'composite'

  steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Print Test Parameters
      run: |
        echo "Integration Test Parameters"
        echo "----------------------------------------"
        echo "Windsor Up: ${{ inputs.windsor_up }}"
        echo "Version: ${{ inputs.version }}"
        echo "Release Branch: ${{ inputs.release_branch }}"
        echo "Release Number: ${{ inputs.release_number }}"
        echo "Windsor Test Config: ${{ inputs.windsor_test_config }}"
        echo "Docker Host: ${{ inputs.docker_host }}"
        echo "Platform: ${{ inputs.platform }}"
        echo "----------------------------------------"
      shell: bash

    ### 
    ### Actual Integration Test
    ### 
    ### 
    # - name: Fix permissions for Linux runners
    #   if: always() && inputs.platform == 'linux'
    #   run: |
    #     sudo chown -R $USER:$USER $GITHUB_WORKSPACE
    #     sudo chmod -R 755 $GITHUB_WORKSPACE
    #   shell: bash
      
    - name: Install Aqua on Linux and macOS
      if: inputs.platform == 'linux' || inputs.platform == 'darwin'
      env: 
        AQUA_DISABLE_COSIGN: true
        AQUA_DISABLE_SLSA: true
      uses: aquaproj/aqua-installer@e2d0136abcf70b7a2f6f505720640750557c4b33 # v3.1.1
      with:
        aqua_version: v2.43.1

    - name: Install Aqua on Windows
      if: inputs.platform == 'win32'
      run: |
        $url = "https://github.com/aquaproj/aqua/releases/download/v2.48.2-0/aqua_windows_amd64.zip"
        $output = "aqua_windows_amd64.zip"
        $installPath = "$env:USERPROFILE\\aqua"
        
        # Remove existing directory if it exists
        if (Test-Path $installPath) {
          Remove-Item -Recurse -Force $installPath
        }
        
        Invoke-WebRequest -Uri $url -OutFile $output
        Expand-Archive -Path $output -DestinationPath $installPath -Force
        
        # Add the install path to the PATH environment variable
        "$installPath" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
        Set-Item Env:Path "$Env:LOCALAPPDATA\aquaproj-aqua\bin;$Env:Path"
        "$Env:LOCALAPPDATA\aquaproj-aqua\bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
        
        # Create custom aqua config without problematic packages for Windows
        Write-Host "Creating custom Aqua config file for Windows..."
        
        $configLines = @(
          "# Custom aqua config for Windows without problematic packages",
          "registries:",
          "- type: standard",
          "  ref: v4.87.0",
          "packages:",
          "- name: hashicorp/terraform@v1.11.4",
          "- name: siderolabs/talos@v1.9.5",
          "- name: siderolabs/omni/omnictl@v0.48.0",
          "- name: siderolabs/omni/omni@v0.48.0",
          "- name: kubernetes/kubectl@v1.32.3",
          "- name: go-task/task@v3.42.1",
          "- name: golang/go@go1.24.2",
          "- name: docker/cli@v27.4.1",
          "- name: docker/compose@v2.34.0",
          "- name: helm/helm@v3.17.3",
          "- name: fluxcd/flux2@v2.5.1",
          "- name: hashicorp/vault@v1.19.1",
          "- name: derailed/k9s@v0.50.2",
          "- name: 1password/cli@v2.30.3",
          "# Skipped problematic packages:",
          "# - getsops/sops@v3.10.1"
        )
        
        # Backup original aqua.yaml if exists
        if (Test-Path aqua.yaml) {
            Copy-Item -Path aqua.yaml -Destination aqua.yaml.bak -Force
        }
        
        # Save custom config
        $configLines | Out-File -FilePath aqua.yaml -Encoding utf8
        
        # Install with custom config
        Write-Host "Installing Aqua packages with custom config..."
        aqua install
        
        # Restore original config if it existed
        if (Test-Path aqua.yaml.bak) {
            Move-Item -Path aqua.yaml.bak -Destination aqua.yaml -Force
        }
      shell: powershell
      
    - name: Install YQ on Windows
      if: inputs.platform == 'win32'
      run: |
        Write-Host "Installing yq on Windows..."
        $yqVersion = "v4.35.1"
        $yqUrl = "https://github.com/mikefarah/yq/releases/download/${yqVersion}/yq_windows_amd64.exe"
        
        # Create bin directory in GitHub workspace to store yq
        $binDir = Join-Path $env:GITHUB_WORKSPACE "bin"
        New-Item -Path $binDir -ItemType Directory -Force | Out-Null
        $yqPath = Join-Path $binDir "yq.exe"
        
        # Download yq
        Write-Host "Downloading yq from $yqUrl to $yqPath"
        Invoke-WebRequest -Uri $yqUrl -OutFile $yqPath
        
        # Add bin directory to PATH
        Write-Host "Adding $binDir to PATH"
        $env:PATH = "$binDir;$env:PATH"
        [Environment]::SetEnvironmentVariable("PATH", $env:PATH, "Process")
        
        # Add to GITHUB_PATH for subsequent steps
        Write-Host "$binDir" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
        
        # Verify yq installation
        try {
            $yqVersion = (& $yqPath --version) 2>&1
            Write-Host "Successfully installed yq: $yqVersion"
        }
        catch {
            Write-Host "Error verifying yq installation: $_"
            exit 1
        }
      shell: powershell

    - name: Print Aqua Path
      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7
      with:
        script: |
          const { execSync } = require('child_process');
          const os = require('os');

          try {
            const platform = os.platform();
            let aquaPathCommand = platform === 'win32' ? 'where aqua' : 'which aqua';

            console.log(`Checking Aqua path on ${platform}...`);
            const aquaPath = execSync(aquaPathCommand, { encoding: 'utf-8' }).trim();
            console.log(`Aqua path: ${aquaPath}`);
          } catch (error) {
            console.error('Error getting Aqua path:', error.message);
            process.exit(1);
          }

    - name: Install Tools
      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7
      with:
        script: |
          const { execSync } = require('child_process');
          const os = require('os');
          const fs = require('fs');

          try {
            const platform = os.platform();
            console.log(`Detected platform: ${platform}`);

            if (platform === 'linux' || platform === 'darwin' || platform === 'win32') {
              console.log('Installing tools using Aqua...');
              
              // Create a temporary aqua.yaml file to skip verification
              const tempAquaConfig = `
              # Temporary aqua config without the problematic package
              registries:
              - type: standard
                ref: v4.87.0
              packages:
              - name: hashicorp/terraform@v1.11.4
              - name: siderolabs/talos@v1.9.5
              - name: siderolabs/omni/omnictl@v0.48.0
              - name: siderolabs/omni/omni@v0.48.0
              - name: kubernetes/kubectl@v1.32.3
              - name: go-task/task@v3.42.1
              - name: golang/go@go1.24.2
              - name: abiosoft/colima@v0.8.1
              - name: lima-vm/lima@v1.0.7
              - name: docker/cli@v27.4.1
              - name: docker/compose@v2.34.0
              - name: aws/aws-cli@2.26.0
              - name: helm/helm@v3.17.3
              - name: fluxcd/flux2@v2.5.1
              - name: hashicorp/vault@v1.19.1
              - name: derailed/k9s@v0.50.2
              - name: 1password/cli@v2.30.3
              # Skipped problematic package: getsops/sops@v3.10.1
              `;
              
              try {
                // Try normal aqua install first
                execSync('aqua install', { stdio: 'inherit' });
                console.log('Tools installed successfully with default configuration.');
              } catch (error) {
                console.log('Initial installation failed, trying with a modified config...');
                
                // Save original aqua.yaml
                const aquaConfigExists = fs.existsSync('aqua.yaml');
                let originalConfig = '';
                if (aquaConfigExists) {
                  originalConfig = fs.readFileSync('aqua.yaml', 'utf8');
                  fs.renameSync('aqua.yaml', 'aqua.yaml.bak');
                }
                
                // Create temp config without problematic packages
                fs.writeFileSync('aqua.yaml', tempAquaConfig);
                
                try {
                  // Install with temp config
                  execSync('aqua install', { stdio: 'inherit' });
                  console.log('Tools installed successfully with modified configuration.');
                } finally {
                  // Restore original aqua.yaml
                  if (aquaConfigExists) {
                    fs.writeFileSync('aqua.yaml', originalConfig);
                  } else {
                    fs.unlinkSync('aqua.yaml');
                  }
                }
              }
            } else {
              console.log('Tool installation is not supported on this platform.');
            }
          } catch (error) {
            console.error('Error installing tools:', error.message);
            core.setFailed(`Failed to install tools: ${error.message}`);
          }

    - name: Set DOCKER_HOST Environment Variable
      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7
      with:
        script: |
          const { execSync } = require('child_process');
          const os = require('os');

          try {
            const platform = os.platform();
            const dockerHost = '${{ inputs.docker_host }}';

            if (dockerHost === '') {
              console.log('dockerHost is empty. DOCKER_HOST will not be set.');
            } else {
              console.log(`Setting DOCKER_HOST for platform: ${platform}`);
              if (platform === 'win32') {
                execSync(`echo "DOCKER_HOST=${dockerHost}" >> $env:GITHUB_ENV`, { stdio: 'inherit', shell: 'powershell' });
              } else {
                execSync(`echo "DOCKER_HOST=${dockerHost}" >> $GITHUB_ENV`, { stdio: 'inherit' });
              }
              console.log(`DOCKER_HOST set to: ${dockerHost}`);
            }
          } catch (error) {
            console.error('Error setting DOCKER_HOST environment variable:', error.message);
            core.setFailed(`Failed to set DOCKER_HOST: ${error.message}`);
          }

    - name: Install Windsor CLI
      uses: windsorcli/action@5b792556ba81bdc6f8abad529343a47f883832cc # v0.3.0
      with:
        version: ${{ (inputs.release_number != '' && !startsWith(inputs.release_number, 'v')) && format('v{0}', inputs.release_number) || (inputs.release_number != '' && startsWith(inputs.release_number, 'v')) && inputs.release_number || inputs.version }}
        ref: ${{ inputs.release_branch }}
        context: "local"

    - name: Get Windsor Context
      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7
      with:
        script: |
          const { execSync } = require('child_process');

          try {
            const windsorContext = execSync('windsor context get', { encoding: 'utf-8' });
            console.log(`Windsor context: ${windsorContext.trim()}`);
          } catch (error) {
            console.error('Error getting Windsor context:', error.message);
            core.setFailed(`Failed to get Windsor context: ${error.message}`);
          }

    - name: Windsor Check
      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7
      with:
        script: |
          const { execSync } = require('child_process');

          try {
            const windsorCheckOutput = execSync('windsor check', { encoding: 'utf-8' });
            console.log(`Windsor check output: ${windsorCheckOutput.trim()}`);
          } catch (error) {
            console.error('Error running Windsor check:', error.message);
            core.setFailed(`Windsor check failed: ${error.message}`);
          }

    - name: Windsor Up
      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7
      with:
        script: |
          const { execSync } = require('child_process');
          const os = require('os');

          try {
            const platform = os.platform();
            const isWindows = platform === 'win32';
            const windsorCommand = isWindows ? 'windsor.exe' : 'windsor';

            console.log(`Detected platform: ${platform}`);

            if (${{ inputs.windsor_up }} === 'true') {
              console.log('Running Windsor Up...');
              const command = isWindows 
                ? `${windsorCommand} up --install --verbose`
                : `${windsorCommand} up --install --verbose`;
              execSync(command, { stdio: 'inherit' });
              console.log('Windsor Up completed successfully.');
            } else {
              console.log('Warning: WINDSOR_UP was not set, skipping Windsor Up');
            }
          } catch (error) {
            console.error('Error running Windsor Up:', error.message);
            core.setFailed(`Windsor Up failed: ${error.message}`);
          }

    - name: Check Pods Status
      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7
      with:
        script: |
          const { execSync } = require('child_process');
          const fs = require('fs');

          try {
            if (!${{ inputs.windsor_up }}) {
              console.log('WINDSOR_UP is not set to true. Skipping Check Pods Status.');
              return;
            }

            const platform = require('os').platform();
            const isWindows = platform === 'win32';
            const windsorCommand = isWindows ? 'windsor.exe' : 'windsor';

            console.log(`Using Windsor CLI at: ${windsorCommand}`);

            // Fetch all pods in all namespaces in JSON format
            execSync(`${windsorCommand} exec -- kubectl get pods -A -o json > pods.json`, { stdio: 'inherit' });

            const podsJson = fs.readFileSync('pods.json', 'utf8');

            if (!podsJson) {
              console.error('No JSON output received. Please check if the Kubernetes cluster is accessible and has pods.');
              core.setFailed('No pod information received from cluster');
              return;
            }

            const pods = JSON.parse(podsJson);

            // Initialize counters
            let runningCount = 0;
            let nonRunningCount = 0;

            // Print header with proper spacing
            console.log(`${'NAMESPACE'.padEnd(20)} ${'POD_NAME'.padEnd(50)} ${'STATUS'.padEnd(10)}`);

            pods.items.forEach(item => {
              const namespace = item.metadata.namespace;
              const podName = item.metadata.name;
              const status = item.status.phase;

              console.log(`${namespace.padEnd(20)} ${podName.padEnd(50)} ${status.padEnd(10)}`);

              if (status !== 'Running') {
                nonRunningCount++;
              } else {
                runningCount++;
              }
            });

            console.log('\nSummary:');
            console.log(`Running pods: ${runningCount}`);
            console.log(`Non-running pods: ${nonRunningCount}`);

            if (nonRunningCount > 0) {
              console.warn(`Warning: There are ${nonRunningCount} pods that are not running.`);
            }
          } catch (error) {
            console.error('Error checking pod status:', error.message);
            core.setFailed(`Failed to check pod status: ${error.message}`);
          }

    - name: Run Tests
      if: inputs.platform == 'linux' || inputs.platform == 'darwin'
      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7
      with:
        script: |
          const { execSync } = require('child_process');
          const os = require('os');
          const fs = require('fs');
          const path = require('path');

          try {
            const platform = os.platform();
            const isWindows = platform === 'win32';
            const windsorExecutable = isWindows ? 'windsor.exe' : 'windsor';
            const installFolder = 'bin';
            const version = '${{ inputs.version }}';
            const arch = process.env.RUNNER_ARCH || 'amd64';
            const workspace = process.env.GITHUB_WORKSPACE;
            const useDocker = process.env.USE_DOCKER === 'true';
            const testConfig = '${{ inputs.windsor_test_config }}';

            console.log(`Running tests on ${platform}...`);

            // Function to execute a command
            const execCommand = (command) => {
              try {
                console.log(`Executing: ${command}`);
                execSync(command, { stdio: 'inherit' });
              } catch (error) {
                console.error(`Error executing command: ${command}`);
                console.error(error.message);
                core.setFailed(`Command execution failed: ${error.message}`);
                return false;
              }
              return true;
            };

            // Function to install a shell if not present
            const installShell = (shellName, ubuntuPkg, macosPkg) => {
              try {
                execSync(`${shellName} --version`, { stdio: 'inherit' });
                console.log(`${shellName} is already installed.`);
                return true;
              } catch {
                console.log(`Installing ${shellName}...`);
                if (platform === 'linux') {
                  return execCommand(`sudo apt-get update && sudo apt-get install -y ${ubuntuPkg}`);
                } else if (platform === 'darwin') {
                  return execCommand(`/opt/homebrew/bin/brew install ${macosPkg}`);
                }
                return false;
              }
            };

            // Function to run a command in a shell
            const runInShell = (shellCmd, scriptPath) => {
              try {
                console.log(`Running ${scriptPath} in ${shellCmd} shell`);
                execSync(`${shellCmd} ${scriptPath}`, { stdio: 'inherit' });
                return true;
              } catch (error) {
                console.error(`Error running ${scriptPath} in ${shellCmd} shell`);
                core.setFailed(`Shell execution failed: ${error.message}`);
                return false;
              }
            };

            // Check the yq version and adjust the command accordingly
            let yqVersion;
            try {
              yqVersion = execSync('yq --version', { encoding: 'utf-8' }).trim();
              console.log(`Using yq version: ${yqVersion}`);
            } catch (error) {
              console.error('Error checking yq version:', error.message);
              core.setFailed(`yq version check failed: ${error.message}`);
              return;
            }

            // Ensure the testConfig path is absolute and correctly quoted
            const testConfigPath = path.isAbsolute(testConfig) ? testConfig : path.join(workspace, testConfig);

            console.log(`Workspace: ${workspace}`);
            console.log(`Test configuration: ${testConfig}`);
            console.log(`Test configuration path: ${testConfigPath}`);

            let testsList;
            try {
              // Use the correct command for yq version 4
              testsList = JSON.parse(execSync(`yq e '.tests-list' -o=json "${testConfigPath}"`, { encoding: 'utf-8' }));
            } catch (error) {
              console.error('Error parsing test configuration:', error.message);
              core.setFailed(`Test configuration parsing failed: ${error.message}`);
              return;
            }

            console.log("=========================================");
            console.log("              STARTING TEST              ");
            console.log("=========================================");

            let testsFailed = false;

            // Loop through each test entry
            testsList.forEach(test => {
              const testPath = test.path;
              const testType = test.type || 'shell';
              const osList = test.os || [];
              const shell = test.shell || 'bash';

              // Install necessary shells
              let shellInstalled = true;
              switch (shell) {
                case 'bash':
                  shellInstalled = installShell('bash', 'bash', 'bash');
                  break;
                case 'zsh':
                  shellInstalled = installShell('zsh', 'zsh', 'zsh');
                  break;
                case 'fish':
                  shellInstalled = installShell('fish', 'fish', 'fish');
                  break;
                case 'pwsh':
                  shellInstalled = installShell('pwsh', 'powershell', 'powershell');
                  break;
                case 'tcsh':
                  shellInstalled = installShell('tcsh', 'tcsh', 'tcsh');
                  break;
                case 'elvish':
                  shellInstalled = installShell('elvish', 'elvish', 'elvish');
                  break;
                default:
                  console.log(`Unknown shell: ${shell}`);
                  shellInstalled = false;
              }

              if (!shellInstalled) {
                console.error(`Failed to install shell: ${shell}`);
                testsFailed = true;
                return;
              }

              // Check if the current OS is supported for the test
              if (osList.length === 0 || osList.includes(platform)) {
                console.log(`Running ${testType} tests using ${shell} shell at ${testPath}`);

                let testSucceeded = true;
                if (useDocker) {
                  const dockerCommand = testType === 'shell' ? `bash ${testPath}` : `bats ${testPath}`;
                  testSucceeded = execCommand(`docker run --rm -i -v "${workspace}":/workspace -w /workspace windsortest:latest ${dockerCommand}`);
                } else {
                  if (testType === 'bats') {
                    const modifiedTestPath = `bats ${testPath}`;
                    // runInShell(shell, modifiedTestPath);
                    console.log(`NOT Running ${testType} tests using ${shell} shell at ${modifiedTestPath}`);
                  } else {
                    testSucceeded = runInShell(shell, testPath);
                  }
                }

                if (!testSucceeded) {
                  testsFailed = true;
                }
              } else {
                console.log(`Skipping ${testType} test at ${testPath} for OS ${platform}`);
              }
            });

            if (testsFailed) {
              core.setFailed('One or more tests failed. Check logs for details.');
              return;
            }

            console.log('Tests completed successfully.');
          } catch (error) {
            console.error('Error running tests:', error.message);
            core.setFailed(`Test execution failed: ${error.message}`);
          }

    - name: Run Tests on Windows
      if: inputs.platform == 'win32'
      run: |
        $testConfig = '${{ inputs.windsor_test_config }}'
        $testConfigPath = if ([System.IO.Path]::IsPathRooted($testConfig)) { $testConfig } else { Join-Path $env:GITHUB_WORKSPACE $testConfig }
        $yqPath = Join-Path $env:GITHUB_WORKSPACE "bin\yq.exe"

        Write-Host "Test configuration path: $testConfigPath"
        
        # Check if the test config file exists
        if (-not (Test-Path $testConfigPath)) {
            Write-Host "Error: Test configuration file not found: $testConfigPath"
            exit 1
        }

        # Read the tests-list from the windsor_test_config file using yq
        try {
            # Use proper yq syntax for Windows with explicit path
            Write-Host "Reading test configuration with yq..."
            
            try {
                Write-Host "Running command: & $yqPath eval '.tests-list' -o=json '$testConfigPath'"
                $tests_list_json = & $yqPath eval '.tests-list' -o=json $testConfigPath
                
                if (-not $tests_list_json) {
                    throw "No output from yq command"
                }
                
                # Convert JSON to PowerShell object
                $tests_list = $tests_list_json | ConvertFrom-Json
                Write-Host "Successfully parsed test configuration with yq"
            } catch {
                Write-Host "Falling back to direct YAML parsing due to yq error: $_"
                
                # Try to install the PowerShell YAML module if yq fails
                Write-Host "Installing PowerShell-YAML module..."
                Install-Module -Name powershell-yaml -Force -Scope CurrentUser -SkipPublisherCheck -AllowClobber
                
                # Read YAML directly with PowerShell
                Write-Host "Reading YAML directly with PowerShell..."
                $yamlContent = Get-Content -Path $testConfigPath -Raw
                
                # Add required module
                Import-Module -Name powershell-yaml
                
                $yaml = ConvertFrom-Yaml -Yaml $yamlContent -Ordered
                $tests_list = $yaml.'tests-list'
                
                if (-not $tests_list) {
                    throw "Could not find tests-list in YAML content"
                }
                
                Write-Host "Successfully parsed YAML with PowerShell module"
            }
        } catch {
            Write-Host "Error reading or parsing YAML file: $_"
            exit 1
        }

        Write-Host "========================================="
        Write-Host "              STARTING TEST              "
        Write-Host "========================================="

        # Loop through each test entry in the tests-list
        foreach ($row in $tests_list) {
            $path = $row.path
            $type = if ($null -eq $row.type) { 'shell' } else { $row.type }
            $os_list = $row.os

            # Check if the current OS is supported for the test
            if (-not $os_list -or $os_list -contains "win32" -or $os_list -contains "windows") {
                try {
                    Write-Host "Running $type tests with path = $path"

                    if ($env:USE_DOCKER -eq "true") {
                        switch ($type) {
                            'shell' {
                                docker run --rm -i `
                                    -v "${env:GITHUB_WORKSPACE}:/workspace" `
                                    -w /workspace `
                                    windsortest:latest `
                                    bash -c "dos2unix '$path' && bash '$path'"
                            }
                            'bats' {
                                docker run --rm -i `
                                    -v "${env:GITHUB_WORKSPACE}:/workspace" `
                                    -w /workspace `
                                    windsortest:latest `
                                    bash -c "bats '$path'"
                            }
                            default {
                                Write-Host "Unknown test type: $type"
                            }
                        }
                    } else {
                        switch ($type) {
                            'shell' {
                                # Add error handling and safer command execution
                                $fullPath = Join-Path $env:GITHUB_WORKSPACE $path
                                Write-Host "Running bash script at $fullPath"
                                
                                # Use -c for PowerShell quoting
                                bash -c "dos2unix '$fullPath' 2>/dev/null || true; bash '$fullPath'"
                                if ($LASTEXITCODE -ne 0) {
                                    throw "Script execution failed with exit code $LASTEXITCODE"
                                }
                            }
                            'bats' {
                                Write-Host "Skipping: bats '$path'"
                            }
                            default {
                                Write-Host "Unknown test type: $type"
                            }
                        }
                    }
                } catch {
                    Write-Host "Error running command for $type tests: $_"
                    exit 1
                }
            } else {
                Write-Host "Skipping $type test at $path for OS win32"
            }
        }
      shell: powershell

    - name: Windsor Down
      if: always() 
      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7
      with:
        script: |
          const { execSync } = require('child_process');
          const os = require('os');

          try {
            // Check if windsor_up is true using only process.env
            // GitHub will have set this env variable from the workflow input
            const windsorUpInput = '${{ inputs.windsor_up }}' === 'true';
            
            if (!windsorUpInput) {
              console.log('WINDSOR_UP is not set to true. Skipping Windsor Down.');
              return;
            }

            const platform = os.platform();
            const isWindows = platform === 'win32';
            const windsorCommand = isWindows ? 'windsor.exe' : 'windsor';

            console.log(`Detected platform: ${platform}`);
            console.log('Running Windsor Down...');

            // Execute the Windsor Down command
            execSync(`${windsorCommand} down --clean`, { stdio: 'inherit' });

            console.log('Windsor Down completed successfully.');
          } catch (error) {
            console.error('Error running Windsor Down:', error.message);
            core.setFailed(`Windsor Down failed: ${error.message}`);
          }

    - name: Docker Clean
      if: always() && (inputs.platform == 'linux' || inputs.platform == 'darwin')
      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7
      with:
        script: |
          const { execSync } = require('child_process');
          const fs = require('fs');

          try {
            // Check if windsor_up is true using only process.env
            // GitHub will have set this env variable from the workflow input
            const windsorUpInput = '${{ inputs.windsor_up }}' === 'true';
            
            if (!windsorUpInput) {
              console.log('WINDSOR_UP is not set to true. Skipping Docker Clean.');
              return;
            }

            // Check if Docker is installed
            try {
              execSync('docker --version', { stdio: 'inherit' });
              console.log('Docker is installed.');
            } catch (error) {
              console.error('Docker is not installed. Exiting.');
              core.setFailed('Docker is not installed');
              return;
            }

            // Check for running containers and remove them
            const containers = execSync('docker ps -aq', { encoding: 'utf-8' }).trim();
            if (containers) {
              console.log('Removing containers...');
              // Replace newlines with spaces to properly format container IDs
              const containerList = containers.replace(/\n/g, ' ');
              execSync(`docker rm -f ${containerList}`, { stdio: 'inherit' });
            } else {
              console.log('No containers to remove.');
            }

            // Prune system, volumes, and networks
            console.log('Pruning Docker system, volumes, and networks...');
            execSync('docker system prune -a -f', { stdio: 'inherit' });
            execSync('docker volume prune -f', { stdio: 'inherit' });
            execSync('docker network prune -f', { stdio: 'inherit' });
            execSync('docker system prune -a -f', { stdio: 'inherit' });

            // Remove .volumes directory if it exists
            if (fs.existsSync('.volumes')) {
              console.log('Removing .volumes directory...');
              fs.rmSync('.volumes', { recursive: true, force: true });
            } else {
              console.log('.volumes directory does not exist.');
            }
          } catch (error) {
            console.error('Error during Docker clean-up:', error.message);
            core.setFailed(`Docker clean-up failed: ${error.message}`);
          }
      
    - name: Docker Clean on Windows
      if: always() && inputs.platform == 'win32'
      run: |
        $windsorUpInput = [bool]::Parse("${{ inputs.windsor_up }}")
        if (-not $windsorUpInput) {
          Write-Output 'WINDSOR_UP is not set to true. Skipping Docker Clean on Windows.'
          exit 0
        }

        $containers = docker ps -aq
        if ($containers) {
          Write-Output "Removing containers..."
          docker rm -f $containers
        } else {
          Write-Output "No containers to remove."
        }

        # Prune system, volumes, and networks
        Write-Output "Pruning Docker system, volumes, and networks..."
        docker system prune -a -f
        docker volume prune -f
        docker network prune -f
        docker system prune -a -f
      shell: powershell
  
    # - name: Fix permissions for Linux runners
    #   if: always() && inputs.platform == 'linux'
    #   run: |
    #     sudo chown -R $USER:$USER $GITHUB_WORKSPACE
    #     sudo chmod -R 755 $GITHUB_WORKSPACE
    #   shell: bash

    - name: Windsor Clean
      if: always() 
      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7
      with:
        script: |
          const fs = require('fs');
          const path = require('path');

          try {
            const workspace = process.env.GITHUB_WORKSPACE;

            if (workspace === '/') {
              console.error('Error: GITHUB_WORKSPACE is the root folder. Aborting cleanup.');
              core.setFailed('GITHUB_WORKSPACE is the root folder');
              return;
            }

            if (!fs.existsSync(workspace) || !fs.lstatSync(workspace).isDirectory()) {
              console.error('Error: GITHUB_WORKSPACE is not a directory. Aborting cleanup.');
              core.setFailed('GITHUB_WORKSPACE is not a directory');
              return;
            }

            const directoriesToRemove = [
              path.join(workspace, '.windsor'),
              path.join(workspace, 'terraform'),
              path.join(workspace, 'kustomize')
            ];

            const filesToRemove = [
              path.join(workspace, '.yamllint'),
              path.join(workspace, '.gitignore'),
              path.join(workspace, '.editorconfig')
            ];

            // Remove directories
            directoriesToRemove.forEach(dir => {
              if (fs.existsSync(dir)) {
                console.log(`Removing directory: ${dir}`);
                fs.rmSync(dir, { recursive: true, force: true });
              }
            });

            // Remove files
            filesToRemove.forEach(file => {
              if (fs.existsSync(file)) {
                console.log(`Removing file: ${file}`);
                fs.rmSync(file, { force: true });
              }
            });

            // Remove all files in the workspace
            fs.readdirSync(workspace).forEach(file => {
              const filePath = path.join(workspace, file);
              if (fs.lstatSync(filePath).isFile()) {
                console.log(`Removing file: ${filePath}`);
                fs.rmSync(filePath, { force: true });
              }
            });

          } catch (error) {
            console.error('Error during Windsor clean-up:', error.message);
            core.setFailed(`Windsor clean-up failed: ${error.message}`);
          }

    - name: Remove tools
      if: always() 
      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7
      with:
        script: |
          const { execSync } = require('child_process');

          try {
            console.log('Removing tools with Aqua...');
            execSync('aqua rm --all', { stdio: 'inherit' });
            console.log('Tools removed successfully.');
          } catch (error) {
            console.error('Error removing tools:', error.message);
            core.setFailed(`Failed to remove tools: ${error.message}`);
          }
    
    - name: Check for Remaining Files
      if: always() 
      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7
      with:
        script: |
          const fs = require('fs');
          const path = require('path');
          const os = require('os');

          try {
            const workspace = process.env.GITHUB_WORKSPACE;
            const platform = os.platform();
            console.log(`Checking for remaining files in the workspace on ${platform}...`);

            let remainingFiles = [];

            if (platform === 'win32') {
              // Windows: Use fs.readdirSync to list files
              remainingFiles = fs.readdirSync(workspace).filter(file => {
                const filePath = path.join(workspace, file);
                return fs.lstatSync(filePath).isFile();
              });
            } else {
              // Linux/macOS: Use fs.readdirSync to list files
              remainingFiles = fs.readdirSync(workspace).filter(file => {
                const filePath = path.join(workspace, file);
                return fs.lstatSync(filePath).isFile();
              });
            }

            if (remainingFiles.length > 0) {
              console.error('Error: Found files in the workspace that should be removed:');
              remainingFiles.forEach(file => console.log(file));
              core.setFailed('Found files in the workspace that should be removed');
              return;
            } else {
              console.log('No remaining files found in the workspace.');
            }
          } catch (error) {
            console.error('Error checking for remaining files:', error.message);
            core.setFailed(`Failed to check for remaining files: ${error.message}`);
          }
    
    ### 
    ### 
    ### 
    ### 
    
    - name: Set Test Results
      id: test_results
      uses: actions/github-script@v7
      with:
        script: |
          try {
            // This is a placeholder - in a real implementation, this would evaluate test outcomes
            // based on the results of previous test steps
            
            // Log some useful debugging information
            console.log('Test configuration:', {
              windsorUp: '${{ inputs.windsor_up }}',
              version: '${{ inputs.version }}',
              releaseBranch: '${{ inputs.release_branch }}',
              releaseNumber: '${{ inputs.release_number }}',
              windsorTestConfig: '${{ inputs.windsor_test_config }}',
              dockerHost: '${{ inputs.docker_host }}',
              platform: '${{ inputs.platform }}'
            });
            
            // In a real implementation, we would determine success/failure based on test results
            // For now, we'll just set success
            core.setOutput('status', 'success');
            console.log('Tests completed. Set status to success.');
          } catch (error) {
            console.error('Error during test execution:', error.message);
            core.setOutput('status', 'failure');
            
            // Don't fail the workflow, just report the status as failure
            // This allows the workflow to continue and report results
            console.log('Setting test status to failure but allowing workflow to continue');
          }
          
    - name: Validate and Report Test Completion
      run: |
        echo "----------------------------------------"
        echo "Integration Test Results"
        echo "----------------------------------------"
        echo "Status: ${{ steps.test_results.outputs.status }}"
        echo "Platform: ${{ inputs.platform }}"
        echo "Windsor Up Used: ${{ inputs.windsor_up }}"
        echo "----------------------------------------"
      shell: bash
    