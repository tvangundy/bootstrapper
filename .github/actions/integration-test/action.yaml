name: 'Integration Test'
description: 'Runs integration tests against Windsor CLI'

inputs:
  windsor_up:
    description: 'Whether to run Windsor Up before tests (true/false)'
    required: false
    type: boolean
    default: false
  version:
    description: 'Version in semantic format (e.g., v1.0.0)'
    required: false
    default: ''
  release_branch:
    description: 'Release branch name (e.g., release-1.0.0, release-latest)'
    required: false
    default: ''
  release_number:
    description: 'Release number (e.g., 1.0.0)'
    required: false
    default: ''
  windsor_test_config:
    description: 'Windsor test configuration file'
    required: false
    default: 'tests/configs/ci-integration-tests.yaml'
  docker_host:
    description: 'Docker host address for remote Docker operations'
    required: false
    default: ''
  platform:
    description: 'Platform OS (e.g., linux, windows)'
    required: false
    default: 'linux'

outputs:
  test_status:
    description: 'Status of the integration tests (success/failure)'
    value: ${{ steps.test_results.outputs.status }}

permissions:
  contents: read

runs:
  using: 'composite'

  steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Print Test Parameters
      run: |
        echo "Integration Test Parameters"
        echo "----------------------------------------"
        echo "Windsor Up: ${{ inputs.windsor_up }}"
        echo "Version: ${{ inputs.version }}"
        echo "Release Branch: ${{ inputs.release_branch }}"
        echo "Release Number: ${{ inputs.release_number }}"
        echo "Windsor Test Config: ${{ inputs.windsor_test_config }}"
        echo "Docker Host: ${{ inputs.docker_host }}"
        echo "Platform: ${{ inputs.platform }}"
        echo "----------------------------------------"
      shell: bash

    ### 
    ### Actual Integration Test
    ### 
    ### 
    # - name: Fix permissions for Linux runners
    #   if: always() && inputs.platform == 'linux'
    #   run: |
    #     sudo chown -R $USER:$USER $GITHUB_WORKSPACE
    #     sudo chmod -R 755 $GITHUB_WORKSPACE
    #   shell: bash
      
    - name: Install Aqua on Linux and macOS
      if: inputs.platform == 'linux' || inputs.platform == 'darwin'
      env: 
        AQUA_DISABLE_COSIGN: true
        AQUA_DISABLE_SLSA: true
      uses: aquaproj/aqua-installer@e2d0136abcf70b7a2f6f505720640750557c4b33 # v3.1.1
      with:
        aqua_version: v2.43.1

    - name: Install Aqua on Windows
      if: inputs.platform == 'win32'
      env: 
        AQUA_DISABLE_COSIGN: true
        AQUA_DISABLE_SLSA: true
      run: |
        $url = "https://github.com/aquaproj/aqua/releases/download/v2.48.2-0/aqua_windows_amd64.zip"
        $output = "aqua_windows_amd64.zip"
        $installPath = "$env:USERPROFILE\\aqua"
        
        # Remove existing directory if it exists
        if (Test-Path $installPath) {
          Remove-Item -Recurse -Force $installPath
        }
        
        Invoke-WebRequest -Uri $url -OutFile $output
        Expand-Archive -Path $output -DestinationPath $installPath -Force
        
        # Add the install path to the PATH environment variable
        "$installPath" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
        Set-Item Env:Path "$Env:LOCALAPPDATA\aquaproj-aqua\bin;$Env:Path"
        "$Env:LOCALAPPDATA\aquaproj-aqua\bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
        
        # Create custom aqua config without problematic packages for Windows
        Write-Host "Creating custom Aqua config file for Windows..."
        
        $configLines = @(
          "# Custom aqua config for Windows without problematic packages",
          "registries:",
          "- type: standard",
          "  ref: v4.87.0",
          "packages:",
          "- name: hashicorp/terraform@v1.11.4",
          "- name: siderolabs/talos@v1.9.5",
          "- name: siderolabs/omni/omnictl@v0.48.0",
          "- name: siderolabs/omni/omni@v0.48.0",
          "- name: kubernetes/kubectl@v1.32.3",
          "- name: go-task/task@v3.42.1",
          "- name: golang/go@go1.24.2",
          "- name: docker/cli@v27.4.1",
          "- name: docker/compose@v2.34.0",
          "- name: helm/helm@v3.17.3",
          "- name: fluxcd/flux2@v2.5.1",
          "- name: hashicorp/vault@v1.19.1",
          "- name: derailed/k9s@v0.50.2",
          "- name: 1password/cli@v2.30.3",
          "# Skipped problematic packages:",
          "# - getsops/sops@v3.10.1"
        )
        
        # Backup original aqua.yaml if exists
        if (Test-Path aqua.yaml) {
            Copy-Item -Path aqua.yaml -Destination aqua.yaml.bak -Force
        }
        
        # Save custom config
        $configLines | Out-File -FilePath aqua.yaml -Encoding utf8
        
        # Install with custom config
        Write-Host "Installing Aqua packages with custom config..."
        aqua install
        
        # Restore original config if it existed
        if (Test-Path aqua.yaml.bak) {
            Move-Item -Path aqua.yaml.bak -Destination aqua.yaml -Force
        }
      shell: powershell
      
    - name: Install YQ on Windows
      if: inputs.platform == 'win32'
      run: |
        Write-Host "Installing yq on Windows..."
        $yqVersion = "v4.35.1"
        $yqUrl = "https://github.com/mikefarah/yq/releases/download/${yqVersion}/yq_windows_amd64.exe"
        
        # Create bin directory in GitHub workspace to store yq
        $binDir = Join-Path $env:GITHUB_WORKSPACE "bin"
        New-Item -Path $binDir -ItemType Directory -Force | Out-Null
        $yqPath = Join-Path $binDir "yq.exe"
        
        # Download yq
        Write-Host "Downloading yq from $yqUrl to $yqPath"
        Invoke-WebRequest -Uri $yqUrl -OutFile $yqPath
        
        # Add bin directory to PATH
        Write-Host "Adding $binDir to PATH"
        $env:PATH = "$binDir;$env:PATH"
        [Environment]::SetEnvironmentVariable("PATH", $env:PATH, "Process")
        
        # Add to GITHUB_PATH for subsequent steps
        Write-Host "$binDir" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
        
        # Verify yq installation
        try {
            $yqVersion = (& $yqPath --version) 2>&1
            Write-Host "Successfully installed yq: $yqVersion"
        }
        catch {
            Write-Host "Error verifying yq installation: $_"
            exit 1
        }
      shell: powershell

    - name: Print Aqua Path
      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7
      with:
        script: |
          const { execSync } = require('child_process');
          const os = require('os');

          try {
            const platform = os.platform();
            let aquaPathCommand = platform === 'win32' ? 'where aqua' : 'which aqua';

            console.log(`Checking Aqua path on ${platform}...`);
            const aquaPath = execSync(aquaPathCommand, { encoding: 'utf-8' }).trim();
            console.log(`Aqua path: ${aquaPath}`);
          } catch (error) {
            console.error('Error getting Aqua path:', error.message);
            process.exit(1);
          }

    - name: Install Tools
      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7
      with:
        script: |
          const { execSync } = require('child_process');
          const os = require('os');
          const fs = require('fs');

          try {
            const platform = os.platform();
            console.log(`Detected platform: ${platform}`);

            if (platform === 'linux' || platform === 'darwin' || platform === 'win32') {
              console.log('Installing tools using Aqua...');
              
              // Create a temporary aqua.yaml file to skip verification
              const tempAquaConfig = `
              # Temporary aqua config without the problematic package
              registries:
              - type: standard
                ref: v4.87.0
              packages:
              - name: hashicorp/terraform@v1.11.4
              - name: siderolabs/talos@v1.9.5
              - name: siderolabs/omni/omnictl@v0.48.0
              - name: siderolabs/omni/omni@v0.48.0
              - name: kubernetes/kubectl@v1.32.3
              - name: go-task/task@v3.42.1
              - name: golang/go@go1.24.2
              - name: abiosoft/colima@v0.8.1
              - name: lima-vm/lima@v1.0.7
              - name: docker/cli@v27.4.1
              - name: docker/compose@v2.34.0
              - name: aws/aws-cli@2.26.0
              - name: helm/helm@v3.17.3
              - name: fluxcd/flux2@v2.5.1
              - name: hashicorp/vault@v1.19.1
              - name: derailed/k9s@v0.50.2
              - name: 1password/cli@v2.30.3
              # Skipped problematic package: getsops/sops@v3.10.1
              `;
              
              try {
                // Try normal aqua install first
                execSync('aqua install', { stdio: 'inherit' });
                console.log('Tools installed successfully with default configuration.');
              } catch (error) {
                console.log('Initial installation failed, trying with a modified config...');
                
                // Save original aqua.yaml
                const aquaConfigExists = fs.existsSync('aqua.yaml');
                let originalConfig = '';
                if (aquaConfigExists) {
                  originalConfig = fs.readFileSync('aqua.yaml', 'utf8');
                  fs.renameSync('aqua.yaml', 'aqua.yaml.bak');
                }
                
                // Create temp config without problematic packages
                fs.writeFileSync('aqua.yaml', tempAquaConfig);
                
                try {
                  // Install with temp config
                  execSync('aqua install', { stdio: 'inherit' });
                  console.log('Tools installed successfully with modified configuration.');
                } finally {
                  // Restore original aqua.yaml
                  if (aquaConfigExists) {
                    fs.writeFileSync('aqua.yaml', originalConfig);
                  } else {
                    fs.unlinkSync('aqua.yaml');
                  }
                }
              }
            } else {
              console.log('Tool installation is not supported on this platform.');
            }
          } catch (error) {
            console.error('Error installing tools:', error.message);
            core.setFailed(`Failed to install tools: ${error.message}`);
          }

    - name: Set DOCKER_HOST Environment Variable
      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7
      with:
        script: |
          const { execSync } = require('child_process');
          const os = require('os');

          try {
            const platform = os.platform();
            const dockerHost = '${{ inputs.docker_host }}';

            if (dockerHost === '') {
              console.log('dockerHost is empty. DOCKER_HOST will not be set.');
            } else {
              console.log(`Setting DOCKER_HOST for platform: ${platform}`);
              if (platform === 'win32') {
                execSync(`echo "DOCKER_HOST=${dockerHost}" >> $env:GITHUB_ENV`, { stdio: 'inherit', shell: 'powershell' });
              } else {
                execSync(`echo "DOCKER_HOST=${dockerHost}" >> $GITHUB_ENV`, { stdio: 'inherit' });
              }
              console.log(`DOCKER_HOST set to: ${dockerHost}`);
            }
          } catch (error) {
            console.error('Error setting DOCKER_HOST environment variable:', error.message);
            core.setFailed(`Failed to set DOCKER_HOST: ${error.message}`);
          }

    - name: Install Windsor CLI
      uses: windsorcli/action@5b792556ba81bdc6f8abad529343a47f883832cc # v0.3.0
      with:
        version: ${{ (inputs.release_number != '' && !startsWith(inputs.release_number, 'v')) && format('v{0}', inputs.release_number) || (inputs.release_number != '' && startsWith(inputs.release_number, 'v')) && inputs.release_number || inputs.version }}
        ref: ${{ inputs.release_branch }}
        context: "local"

    - name: Get Windsor Context
      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7
      with:
        script: |
          const { execSync } = require('child_process');

          try {
            const windsorContext = execSync('windsor context get', { encoding: 'utf-8' });
            console.log(`Windsor context: ${windsorContext.trim()}`);
          } catch (error) {
            console.error('Error getting Windsor context:', error.message);
            core.setFailed(`Failed to get Windsor context: ${error.message}`);
          }

    - name: Windsor Check
      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7
      with:
        script: |
          const { execSync } = require('child_process');

          try {
            const windsorCheckOutput = execSync('windsor check', { encoding: 'utf-8' });
            console.log(`Windsor check output: ${windsorCheckOutput.trim()}`);
          } catch (error) {
            console.error('Error running Windsor check:', error.message);
            core.setFailed(`Windsor check failed: ${error.message}`);
          }

    - name: Windsor Up
      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7
      with:
        script: |
          const { execSync } = require('child_process');
          const os = require('os');

          try {
            const platform = os.platform();
            const isWindows = platform === 'win32';
            const windsorCommand = isWindows ? 'windsor.exe' : 'windsor';

            console.log(`Detected platform: ${platform}`);

            if (${{ inputs.windsor_up }} === 'true') {
              console.log('Running Windsor Up...');
              const command = isWindows 
                ? `${windsorCommand} up --install --verbose`
                : `${windsorCommand} up --install --verbose`;
              execSync(command, { stdio: 'inherit' });
              console.log('Windsor Up completed successfully.');
            } else {
              console.log('Warning: WINDSOR_UP was not set, skipping Windsor Up');
            }
          } catch (error) {
            console.error('Error running Windsor Up:', error.message);
            core.setFailed(`Windsor Up failed: ${error.message}`);
          }

    - name: Check Pods Status
      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7
      with:
        script: |
          const { execSync } = require('child_process');
          const fs = require('fs');

          try {
            if (!${{ inputs.windsor_up }}) {
              console.log('WINDSOR_UP is not set to true. Skipping Check Pods Status.');
              return;
            }

            const platform = require('os').platform();
            const isWindows = platform === 'win32';
            const windsorCommand = isWindows ? 'windsor.exe' : 'windsor';

            console.log(`Using Windsor CLI at: ${windsorCommand}`);

            // Fetch all pods in all namespaces in JSON format
            execSync(`${windsorCommand} exec -- kubectl get pods -A -o json > pods.json`, { stdio: 'inherit' });

            const podsJson = fs.readFileSync('pods.json', 'utf8');

            if (!podsJson) {
              console.error('No JSON output received. Please check if the Kubernetes cluster is accessible and has pods.');
              core.setFailed('No pod information received from cluster');
              return;
            }

            const pods = JSON.parse(podsJson);

            // Initialize counters
            let runningCount = 0;
            let nonRunningCount = 0;

            // Print header with proper spacing
            console.log(`${'NAMESPACE'.padEnd(20)} ${'POD_NAME'.padEnd(50)} ${'STATUS'.padEnd(10)}`);

            pods.items.forEach(item => {
              const namespace = item.metadata.namespace;
              const podName = item.metadata.name;
              const status = item.status.phase;

              console.log(`${namespace.padEnd(20)} ${podName.padEnd(50)} ${status.padEnd(10)}`);

              if (status !== 'Running') {
                nonRunningCount++;
              } else {
                runningCount++;
              }
            });

            console.log('\nSummary:');
            console.log(`Running pods: ${runningCount}`);
            console.log(`Non-running pods: ${nonRunningCount}`);

            if (nonRunningCount > 0) {
              console.warn(`Warning: There are ${nonRunningCount} pods that are not running.`);
            }
          } catch (error) {
            console.error('Error checking pod status:', error.message);
            core.setFailed(`Failed to check pod status: ${error.message}`);
          }

    - name: Run Tests on Linux and MacOS
      if: inputs.platform != 'win32'
      run: |
        echo "========================================="
        echo "          PREPARING TEST ENVIRONMENT     "
        echo "========================================="
        
        # Set variables
        testConfig="${{ inputs.windsor_test_config }}"
        
        # Determine if the path is absolute or relative
        if [[ "$testConfig" == /* ]]; then
          testConfigPath="$testConfig"
        else
          testConfigPath="$GITHUB_WORKSPACE/$testConfig"
        fi
        
        echo "Test configuration path: $testConfigPath"
        
        # Check if the test config file exists
        if [ ! -f "$testConfigPath" ]; then
          echo "Error: Test configuration file not found: $testConfigPath"
          exit 1
        fi

        # Try to read tests from YAML file
        echo "Reading test configuration..."
        
        # Parse YAML file manually
        parse_yaml() {
          # Function to parse YAML and extract tests-list
          local file="$1"
          local yaml_content=$(<"$file")
          
          # Check if tests-list section exists
          if ! grep -q "tests-list:" "$file"; then
            echo "Error: tests-list section not found in YAML file"
            return 1
          fi
          
          # Extract tests-list section using a more reliable approach
          local in_tests_section=false
          local test_indent=""
          local current_test_path=""
          local current_test_type="shell"
          local current_test_shell="bash"
          local current_test_os=""
          local processed_tests=()
          local in_test=false
          local collecting_array=false
          local array_property=""
          local array_value=""
          
          # Process line by line with proper section detection
          while IFS= read -r line; do
            # Check for tests-list section start
            if [[ "$line" =~ ^[[:space:]]*tests-list:[[:space:]]*$ ]]; then
              in_tests_section=true
              continue
            fi
            
            # Skip if not in tests-list section
            if [[ "$in_tests_section" != true ]]; then
              continue
            fi
            
            # Skip empty lines
            [[ -z "$line" ]] && continue
            
            # Check for section end (any line with less indentation than the test items)
            if [[ -n "$test_indent" && "$line" =~ ^[[:space:]]{0,$((${#test_indent}-1))}[^[:space:]] && ! "$line" =~ ^[[:space:]]*- ]]; then
              in_tests_section=false
              break
            fi
            
            # Detect test item start
            if [[ "$line" =~ ^([[:space:]]*)- ]]; then
              # First test item - determine indent level
              if [[ -z "$test_indent" ]]; then
                test_indent="${BASH_REMATCH[1]}"
              fi
              
              # Save previous test if exists
              if [[ -n "$current_test_path" ]]; then
                processed_tests+=("$current_test_path|$current_test_type|$current_test_shell|$current_test_os")
              fi
              
              # Reset for new test
              current_test_path=""
              current_test_type="shell"
              current_test_shell="bash"
              current_test_os=""
              in_test=true
              collecting_array=false
              
              # Extract property if on same line
              if [[ "$line" =~ ^[[:space:]]*-[[:space:]]*([^:]+):[[:space:]]*(.+)$ ]]; then
                key="${BASH_REMATCH[1]}"
                value="${BASH_REMATCH[2]}"
                
                case "$key" in
                  path) current_test_path="$value" ;;
                  type) current_test_type="$value" ;;
                  shell) current_test_shell="$value" ;;
                  os) 
                    # Handle os property in array format [val1, val2] or starting multi-line array
                    if [[ "$value" =~ ^\[(.*)\]$ ]]; then
                      # Array in single line format [val1, val2]
                      current_test_os="${BASH_REMATCH[1]}"
                    elif [[ "$value" == "[" ]]; then
                      # Start of multi-line array
                      collecting_array=true
                      array_property="os"
                      array_value=""
                    else
                      current_test_os="$value"
                    fi
                    ;;
                esac
              fi
            elif [[ "$in_test" == true && ! "$collecting_array" == true && "$line" =~ ^[[:space:]]*([^:]+):[[:space:]]*(.+)$ ]]; then
              # Regular property within a test
              key="${BASH_REMATCH[1]}"
              value="${BASH_REMATCH[2]}"
              
              case "$key" in
                path) current_test_path="$value" ;;
                type) current_test_type="$value" ;;
                shell) current_test_shell="$value" ;;
                os)
                  # Handle os property in array format [val1, val2] or starting multi-line array
                  if [[ "$value" =~ ^\[(.*)\]$ ]]; then
                    # Array in single line format [val1, val2]
                    current_test_os="${BASH_REMATCH[1]}"
                  elif [[ "$value" == "[" ]]; then
                    # Start of multi-line array
                    collecting_array=true
                    array_property="os"
                    array_value=""
                  else
                    current_test_os="$value"
                  fi
                  ;;
              esac
            elif [[ "$collecting_array" == true && "$line" =~ ^[[:space:]]*(.+)$ ]]; then
              # Array item in a multi-line array
              item="${BASH_REMATCH[1]}"
              # Remove trailing commas
              item="${item%,}"
              
              # Add item to array value
              array_value+="$item,"
            elif [[ "$collecting_array" == true && "$line" =~ ^[[:space:]]*\]$ ]]; then
              # End of multi-line array
              collecting_array=false
              
              # Assign array value to appropriate property
              if [[ "$array_property" == "os" ]]; then
                current_test_os="${array_value%,}" # Remove trailing comma
              fi
            fi
          done < "$file"
          
          # Add the last test if we ended while still in a test
          if [[ "$in_test" == true && -n "$current_test_path" ]]; then
            processed_tests+=("$current_test_path|$current_test_type|$current_test_shell|$current_test_os")
          fi
          
          # Check if we found any tests
          if [[ ${#processed_tests[@]} -eq 0 ]]; then
            echo "Error: No valid tests found in tests-list section"
            return 1
          fi
          
          # Output tests
          for test in "${processed_tests[@]}"; do
            echo "$test"
          done
          
          return 0
        }
        
        # Parse the YAML
        parsed_tests=()
        if ! parse_data=$(parse_yaml "$testConfigPath"); then
          echo "$parse_data"  # Show the error message
          exit 1
        else
          # Convert output to array
          while read -r line; do
            [[ -n "$line" ]] && parsed_tests+=("$line")
          done <<< "$parse_data"
        fi
        
        if [ ${#parsed_tests[@]} -eq 0 ]; then
          echo "Error: No tests found in configuration file"
          exit 1
        fi
        
        echo "Found ${#parsed_tests[@]} tests in configuration"
        
        # Print discovered tests
        for test_info in "${parsed_tests[@]}"; do
          IFS='|' read -r path type shell os_list <<< "$test_info"
          echo "Found test: Path=$path, Type=$type, Shell=$shell, OS=$os_list"
        done
        
        echo "========================================="
        echo "              STARTING TEST              "
        echo "========================================="
        
        # Set up success/failure counters
        success_count=0
        fail_count=0
        
        # Loop through each test entry
        for test_info in "${parsed_tests[@]}"; do
          IFS='|' read -r path type shell os_list <<< "$test_info"
          
          # Check if the path is empty
          if [ -z "$path" ]; then
            echo "Error: Test missing path property"
            ((fail_count++))
            continue
          fi
          
          # Get current OS
          current_os=$(uname | tr '[:upper:]' '[:lower:]')
          if [ "$current_os" == "darwin" ]; then
            current_os="darwin"
          else
            current_os="linux"
          fi
          
          # Clean up OS list (remove whitespace)
          os_list=$(echo "$os_list" | tr -d '[:space:]')
          
          # Check if the current OS is supported for the test
          if [[ -z "$os_list" || "$os_list" == *"$current_os"* || "$os_list" == *"$PLATFORM"* ]]; then
            echo "Running $type tests with path = $path"
            
            # Use absolute path
            if [[ "$path" == /* ]]; then
              full_path="$path"
            else
              full_path="$GITHUB_WORKSPACE/$path"
            fi
            
            # Run the test
            if [ "$USE_DOCKER" == "true" ]; then
              echo "Running test in Docker..."
              if ! docker run --rm -i \
                -v "$GITHUB_WORKSPACE:/workspace" \
                -w /workspace \
                windsortest:latest \
                bash -c "chmod +x '$path' && bash '$path'"; then
                echo "Error: Docker test failed"
                ((fail_count++))
                continue
              fi
            else
              echo "Running test directly with Bash..."
              
              # Check if path is a directory and type is bats
              if [ -d "$full_path" ] && [ "$type" == "bats" ]; then
                echo "Path is a directory and type is 'bats', looking for .bats files..."
                bats_files=$(find "$full_path" -name "*.bats" -type f)
                
                if [ -z "$bats_files" ]; then
                  echo "Error: No .bats files found in directory: $full_path"
                  ((fail_count++))
                  continue
                fi
                
                echo "Found $(echo "$bats_files" | wc -l | tr -d ' ') .bats files"
                
                # Check if bats is installed
                if ! command -v bats &> /dev/null; then
                  echo "Installing bats-core..."
                  if [ "$(uname)" == "Darwin" ]; then
                    # macOS
                    brew install bats-core || {
                      echo "Error: Failed to install bats-core" 
                      ((fail_count++))
                      continue
                    }
                  else
                    # Linux
                    npm install -g bats || {
                      echo "Error: Failed to install bats-core" 
                      ((fail_count++))
                      continue
                    }
                  fi
                fi
                
                # Run all bats files
                test_success=true
                for bats_file in $bats_files; do
                  echo "Running bats test: $bats_file"
                  if ! bats "$bats_file"; then
                    echo "Error: Bats test failed: $bats_file"
                    test_success=false
                  fi
                done
                
                if [ "$test_success" == "false" ]; then
                  ((fail_count++))
                  continue
                fi
              elif [ -f "$full_path" ]; then
                # Regular file test
                chmod +x "$full_path"
                if ! bash "$full_path"; then
                  echo "Error: Script execution failed"
                  ((fail_count++))
                  continue
                fi
              else
                echo "Error: Path is neither a valid file nor a directory containing bats tests: $full_path"
                ((fail_count++))
                continue
              fi
              
              # If we got here, the test was successful
              ((success_count++))
              echo "Test executed successfully"
            fi
          else
            echo "Skipping $type test at $path for OS $current_os"
          fi
        done
        
        echo "========================================="
        echo "           TEST EXECUTION SUMMARY        "
        echo "========================================="
        echo "Success: $success_count"
        echo "Failed:  $fail_count"
        
        if [ $fail_count -gt 0 ]; then
          echo "One or more tests failed!"
          exit 1
        fi
      shell: bash

    - name: Run Tests on Windows
      if: inputs.platform == 'win32'
      run: |
        $testConfig = '${{ inputs.windsor_test_config }}'
        $testConfigPath = if ([System.IO.Path]::IsPathRooted($testConfig)) { $testConfig } else { Join-Path $env:GITHUB_WORKSPACE $testConfig }

        Write-Host "Test configuration path: $testConfigPath"
        
        # Check if the test config file exists
        if (-not (Test-Path $testConfigPath)) {
            Write-Host "Error: Test configuration file not found: $testConfigPath"
            exit 1
        }

        # Simple YAML parsing for tests-list section
        try {
            Write-Host "Reading test configuration file directly..."
            
            # Read the entire file content
            $yamlContent = Get-Content -Path $testConfigPath -Raw
            
            # First check if tests-list section exists at all
            if ($yamlContent -notmatch "tests-list:") {
                Write-Host "Error: tests-list section not found in YAML file"
                exit 1
            }
            
            # Process line by line for more reliable extraction
            $inTestsSection = $false
            $testIndent = $null
            $tests = @()
            $currentTestPath = $null
            $currentTestType = "shell"
            $currentTestShell = "bash"
            $currentTestOs = $null
            $inTest = $false
            $collectingArray = $false
            $arrayProperty = $null
            $arrayValue = $null
            
            # Process line by line
            foreach ($line in ($yamlContent -split "`n")) {
                # Check for tests-list section start
                if ($line -match "^\s*tests-list:\s*$") {
                    $inTestsSection = $true
                    continue
                }
                
                # Skip if not in tests-list section
                if (-not $inTestsSection) {
                    continue
                }
                
                # Skip empty lines
                if ([string]::IsNullOrWhiteSpace($line)) {
                    continue
                }
                
                # Check for section end
                if ($testIndent -and $line -match "^(\s{0,$($testIndent.Length-1)})[^\s]" -and $line -notmatch "^\s*-") {
                    $inTestsSection = $false
                    break
                }
                
                # Detect test item start
                if ($line -match "^(\s*)-\s") {
                    $lineIndent = $matches[1]
                    
                    # First test item - determine indent level
                    if (-not $testIndent) {
                        $testIndent = $lineIndent
                    }
                    
                    # Save previous test if exists
                    if ($currentTestPath) {
                        $tests += @{
                            path = $currentTestPath
                            type = $currentTestType
                            shell = $currentTestShell
                            os = $currentTestOs
                        }
                    }
                    
                    # Reset test properties
                    $currentTestPath = $null
                    $currentTestType = "shell"
                    $currentTestShell = "bash"
                    $currentTestOs = $null
                    $inTest = $true
                    $collectingArray = $false
                    
                    # Extract property if on same line
                    if ($line -match "^\s*-\s+([^:]+):\s*(.+)$") {
                        $key = $matches[1].Trim()
                        $value = $matches[2].Trim()
                        
                        switch ($key) {
                            "path" { $currentTestPath = $value }
                            "type" { $currentTestType = $value }
                            "shell" { $currentTestShell = $value }
                            "os" {
                                # Handle os property in array format [val1, val2] or starting multi-line array
                                if ($value -match "^\[(.*)\]$") {
                                    # Array in single line format [val1, val2]
                                    $currentTestOs = $matches[1]
                                } elseif ($value -eq "[") {
                                    # Start of multi-line array
                                    $collectingArray = $true
                                    $arrayProperty = "os"
                                    $arrayValue = ""
                                } else {
                                    $currentTestOs = $value
                                }
                            }
                        }
                    }
                } elseif ($inTest -and -not $collectingArray -and $line -match "^\s+([^:]+):\s*(.+)$") {
                    # Regular property within a test
                    $key = $matches[1].Trim()
                    $value = $matches[2].Trim()
                    
                    switch ($key) {
                        "path" { $currentTestPath = $value }
                        "type" { $currentTestType = $value }
                        "shell" { $currentTestShell = $value }
                        "os" {
                            # Handle os property in array format [val1, val2] or starting multi-line array
                            if ($value -match "^\[(.*)\]$") {
                                # Array in single line format [val1, val2]
                                $currentTestOs = $matches[1]
                            } elseif ($value -eq "[") {
                                # Start of multi-line array
                                $collectingArray = $true
                                $arrayProperty = "os"
                                $arrayValue = ""
                            } else {
                                $currentTestOs = $value
                            }
                        }
                    }
                } elseif ($collectingArray -and $line -match "^\s+(.+)$") {
                    # Array item in a multi-line array
                    $item = $matches[1].Trim()
                    # Remove trailing commas
                    $item = $item -replace ",\s*$", ""
                    
                    # Add item to array value
                    $arrayValue += "$item,"
                } elseif ($collectingArray -and $line -match "^\s*\]$") {
                    # End of multi-line array
                    $collectingArray = $false
                    
                    # Assign array value to appropriate property
                    if ($arrayProperty -eq "os") {
                        $currentTestOs = $arrayValue.TrimEnd(',')
                    }
                }
            }
            
            # Add the last test if we ended while still in a test
            if ($inTest -and $currentTestPath) {
                $tests += @{
                    path = $currentTestPath
                    type = $currentTestType
                    shell = $currentTestShell
                    os = $currentTestOs
                }
            }
            
            # Check if any valid tests were found
            if ($tests.Count -eq 0) {
                Write-Host "Error: No valid tests found in tests-list section"
                exit 1
            }
            
            Write-Host "Successfully parsed $($tests.Count) tests from config file"
            
            # Print discovered tests
            foreach ($test in $tests) {
                Write-Host "Found test: Path=$($test.path), Type=$($test.type), Shell=$($test.shell), OS=$($test.os)"
            }
        } catch {
            Write-Host "Error parsing YAML file: $_"
            exit 1
        }

        Write-Host "========================================="
        Write-Host "              STARTING TEST              "
        Write-Host "========================================="

        # Count for test results
        $successCount = 0
        $failCount = 0

        # Loop through each test entry
        foreach ($test in $tests) {
            $path = $test.path
            if (-not $path) {
                Write-Host "Error: Test missing path property"
                $failCount++
                continue
            }
            
            $type = $test.type
            $shell = $test.shell
            
            # Clean up OS list (remove whitespace)
            $osList = $test.os -replace '\s+', ''
            
            # Check if the current OS is supported for the test
            if (-not $osList -or $osList.Count -eq 0 -or $osList -match "win32" -or $osList -match "windows") {
                try {
                    Write-Host "Running $type tests with path = $path"

                    # Use absolute path
                    $fullPath = if ([System.IO.Path]::IsPathRooted($path)) { $path } else { Join-Path $env:GITHUB_WORKSPACE $path }
                    
                    if ($env:USE_DOCKER -eq "true") {
                        Write-Host "Running test in Docker..."
                        docker run --rm -i `
                            -v "${env:GITHUB_WORKSPACE}:/workspace" `
                            -w /workspace `
                            windsortest:latest `
                            bash -c "chmod +x '$path' && bash '${path}'"
                        
                        if ($LASTEXITCODE -ne 0) {
                            throw "Docker test failed with exit code $LASTEXITCODE"
                        }
                    } else {
                        # Check if path is a directory and type is bats
                        if ((Test-Path -Path $fullPath -PathType Container) -and $type -eq "bats") {
                            Write-Host "Path is a directory and type is 'bats', looking for .bats files..."
                            $batsFiles = Get-ChildItem -Path $fullPath -Filter "*.bats" -Recurse -File
                            
                            if ($batsFiles.Count -eq 0) {
                                Write-Host "Error: No .bats files found in directory: $fullPath"
                                $failCount++
                                continue
                            }
                            
                            Write-Host "Found $($batsFiles.Count) .bats files"
                            
                            # Check if bats is installed
                            try {
                                $batsVersion = Invoke-Expression "bats --version" 2>&1
                                Write-Host "Using bats version: $batsVersion"
                            } catch {
                                Write-Host "Installing bats-core..."
                                try {
                                    # Try using npm to install bats
                                    Invoke-Expression "npm install -g bats" 2>&1
                                } catch {
                                    Write-Host "Error: Failed to install bats-core"
                                    $failCount++
                                    continue
                                }
                            }
                            
                            # Run all bats files
                            $testSuccess = $true
                            foreach ($batsFile in $batsFiles) {
                                Write-Host "Running bats test: $($batsFile.FullName)"
                                try {
                                    # Convert to Unix line endings and run bats
                                    Invoke-Expression "dos2unix '$($batsFile.FullName)' 2>/dev/null || true"
                                    Invoke-Expression "bats '$($batsFile.FullName)'"
                                    
                                    if ($LASTEXITCODE -ne 0) {
                                        Write-Host "Error: Bats test failed: $($batsFile.FullName)"
                                        $testSuccess = $false
                                    }
                                } catch {
                                    Write-Host "Error running bats test: $_"
                                    $testSuccess = $false
                                }
                            }
                            
                            if (-not $testSuccess) {
                                $failCount++
                                continue
                            }
                        } elseif (Test-Path -Path $fullPath -PathType Leaf) {
                            Write-Host "Running test directly with Bash..."
                            # Use -c for PowerShell quoting
                            bash -c "dos2unix '${fullPath}' 2>/dev/null || true; bash '${fullPath}'"
                            
                            if ($LASTEXITCODE -ne 0) {
                                throw "Script execution failed with exit code $LASTEXITCODE"
                            }
                        } else {
                            Write-Host "Error: Path is neither a valid file nor a directory containing bats tests: $fullPath"
                            $failCount++
                            continue
                        }
                    }
                    
                    $successCount++
                    echo "Test executed successfully"
                } catch {
                    Write-Host "Error running test: $_"
                    $failCount++
                }
            } else {
                Write-Host "Skipping $type test at $path for OS win32"
            }
        }

        Write-Host "========================================="
        Write-Host "           TEST EXECUTION SUMMARY        "
        Write-Host "========================================="
        Write-Host "Success: $successCount"
        Write-Host "Failed:  $failCount"
        
        if ($failCount -gt 0) {
            Write-Host "One or more tests failed!"
            exit 1
        }
      shell: powershell

    - name: Windsor Down
      if: always() 
      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7
      with:
        script: |
          const { execSync } = require('child_process');
          const os = require('os');

          try {
            // Check if windsor_up is true using only process.env
            // GitHub will have set this env variable from the workflow input
            const windsorUpInput = '${{ inputs.windsor_up }}' === 'true';
            
            if (!windsorUpInput) {
              console.log('WINDSOR_UP is not set to true. Skipping Windsor Down.');
              return;
            }

            const platform = os.platform();
            const isWindows = platform === 'win32';
            const windsorCommand = isWindows ? 'windsor.exe' : 'windsor';

            console.log(`Detected platform: ${platform}`);
            console.log('Running Windsor Down...');

            // Execute the Windsor Down command
            execSync(`${windsorCommand} down --clean`, { stdio: 'inherit' });

            console.log('Windsor Down completed successfully.');
          } catch (error) {
            console.error('Error running Windsor Down:', error.message);
            core.setFailed(`Windsor Down failed: ${error.message}`);
          }

    - name: Docker Clean
      if: always() && (inputs.platform == 'linux' || inputs.platform == 'darwin')
      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7
      with:
        script: |
          const { execSync } = require('child_process');
          const fs = require('fs');

          try {
            // Check if windsor_up is true using only process.env
            // GitHub will have set this env variable from the workflow input
            const windsorUpInput = '${{ inputs.windsor_up }}' === 'true';
            
            if (!windsorUpInput) {
              console.log('WINDSOR_UP is not set to true. Skipping Docker Clean.');
              return;
            }

            // Check if Docker is installed
            try {
              execSync('docker --version', { stdio: 'inherit' });
              console.log('Docker is installed.');
            } catch (error) {
              console.error('Docker is not installed. Exiting.');
              core.setFailed('Docker is not installed');
              return;
            }

            // Check for running containers and remove them
            const containers = execSync('docker ps -aq', { encoding: 'utf-8' }).trim();
            if (containers) {
              console.log('Removing containers...');
              // Replace newlines with spaces to properly format container IDs
              const containerList = containers.replace(/\n/g, ' ');
              execSync(`docker rm -f ${containerList}`, { stdio: 'inherit' });
            } else {
              console.log('No containers to remove.');
            }

            // Prune system, volumes, and networks
            console.log('Pruning Docker system, volumes, and networks...');
            execSync('docker system prune -a -f', { stdio: 'inherit' });
            execSync('docker volume prune -f', { stdio: 'inherit' });
            execSync('docker network prune -f', { stdio: 'inherit' });
            execSync('docker system prune -a -f', { stdio: 'inherit' });

            // Remove .volumes directory if it exists
            if (fs.existsSync('.volumes')) {
              console.log('Removing .volumes directory...');
              fs.rmSync('.volumes', { recursive: true, force: true });
            } else {
              console.log('.volumes directory does not exist.');
            }
          } catch (error) {
            console.error('Error during Docker clean-up:', error.message);
            core.setFailed(`Docker clean-up failed: ${error.message}`);
          }
      
    - name: Docker Clean on Windows
      if: always() && inputs.platform == 'win32'
      run: |
        $windsorUpInput = [bool]::Parse("${{ inputs.windsor_up }}")
        if (-not $windsorUpInput) {
          Write-Output 'WINDSOR_UP is not set to true. Skipping Docker Clean on Windows.'
          exit 0
        }

        $containers = docker ps -aq
        if ($containers) {
          Write-Output "Removing containers..."
          docker rm -f $containers
        } else {
          Write-Output "No containers to remove."
        }

        # Prune system, volumes, and networks
        Write-Output "Pruning Docker system, volumes, and networks..."
        docker system prune -a -f
        docker volume prune -f
        docker network prune -f
        docker system prune -a -f
      shell: powershell
  
    # - name: Fix permissions for Linux runners
    #   if: always() && inputs.platform == 'linux'
    #   run: |
    #     sudo chown -R $USER:$USER $GITHUB_WORKSPACE
    #     sudo chmod -R 755 $GITHUB_WORKSPACE
    #   shell: bash

    - name: Windsor Clean
      if: always() 
      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7
      with:
        script: |
          const fs = require('fs');
          const path = require('path');

          try {
            const workspace = process.env.GITHUB_WORKSPACE;

            if (workspace === '/') {
              console.error('Error: GITHUB_WORKSPACE is the root folder. Aborting cleanup.');
              core.setFailed('GITHUB_WORKSPACE is the root folder');
              return;
            }

            if (!fs.existsSync(workspace) || !fs.lstatSync(workspace).isDirectory()) {
              console.error('Error: GITHUB_WORKSPACE is not a directory. Aborting cleanup.');
              core.setFailed('GITHUB_WORKSPACE is not a directory');
              return;
            }

            const directoriesToRemove = [
              path.join(workspace, '.windsor'),
              path.join(workspace, 'terraform'),
              path.join(workspace, 'kustomize')
            ];

            const filesToRemove = [
              path.join(workspace, '.yamllint'),
              path.join(workspace, '.gitignore'),
              path.join(workspace, '.editorconfig')
            ];

            // Remove directories
            directoriesToRemove.forEach(dir => {
              if (fs.existsSync(dir)) {
                console.log(`Removing directory: ${dir}`);
                fs.rmSync(dir, { recursive: true, force: true });
              }
            });

            // Remove files
            filesToRemove.forEach(file => {
              if (fs.existsSync(file)) {
                console.log(`Removing file: ${file}`);
                fs.rmSync(file, { force: true });
              }
            });

            // Remove all files in the workspace
            fs.readdirSync(workspace).forEach(file => {
              const filePath = path.join(workspace, file);
              if (fs.lstatSync(filePath).isFile()) {
                console.log(`Removing file: ${filePath}`);
                fs.rmSync(filePath, { force: true });
              }
            });

          } catch (error) {
            console.error('Error during Windsor clean-up:', error.message);
            core.setFailed(`Windsor clean-up failed: ${error.message}`);
          }

    - name: Remove tools
      if: always() 
      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7
      with:
        script: |
          const { execSync } = require('child_process');

          try {
            console.log('Removing tools with Aqua...');
            execSync('aqua rm --all', { stdio: 'inherit' });
            console.log('Tools removed successfully.');
          } catch (error) {
            console.error('Error removing tools:', error.message);
            core.setFailed(`Failed to remove tools: ${error.message}`);
          }
    
    - name: Check for Remaining Files
      if: always() 
      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7
      with:
        script: |
          const fs = require('fs');
          const path = require('path');
          const os = require('os');

          try {
            const workspace = process.env.GITHUB_WORKSPACE;
            const platform = os.platform();
            console.log(`Checking for remaining files in the workspace on ${platform}...`);

            let remainingFiles = [];

            if (platform === 'win32') {
              // Windows: Use fs.readdirSync to list files
              remainingFiles = fs.readdirSync(workspace).filter(file => {
                const filePath = path.join(workspace, file);
                return fs.lstatSync(filePath).isFile();
              });
            } else {
              // Linux/macOS: Use fs.readdirSync to list files
              remainingFiles = fs.readdirSync(workspace).filter(file => {
                const filePath = path.join(workspace, file);
                return fs.lstatSync(filePath).isFile();
              });
            }

            if (remainingFiles.length > 0) {
              console.error('Error: Found files in the workspace that should be removed:');
              remainingFiles.forEach(file => console.log(file));
              core.setFailed('Found files in the workspace that should be removed');
              return;
            } else {
              console.log('No remaining files found in the workspace.');
            }
          } catch (error) {
            console.error('Error checking for remaining files:', error.message);
            core.setFailed(`Failed to check for remaining files: ${error.message}`);
          }
    
    ### 
    ### 
    ### 
    ### 
    
    - name: Set Test Results
      id: test_results
      uses: actions/github-script@v7
      with:
        script: |
          try {
            // This is a placeholder - in a real implementation, this would evaluate test outcomes
            // based on the results of previous test steps
            
            // Log some useful debugging information
            console.log('Test configuration:', {
              windsorUp: '${{ inputs.windsor_up }}',
              version: '${{ inputs.version }}',
              releaseBranch: '${{ inputs.release_branch }}',
              releaseNumber: '${{ inputs.release_number }}',
              windsorTestConfig: '${{ inputs.windsor_test_config }}',
              dockerHost: '${{ inputs.docker_host }}',
              platform: '${{ inputs.platform }}'
            });
            
            // In a real implementation, we would determine success/failure based on test results
            // For now, we'll just set success
            core.setOutput('status', 'success');
            console.log('Tests completed. Set status to success.');
          } catch (error) {
            console.error('Error during test execution:', error.message);
            core.setOutput('status', 'failure');
            
            // Don't fail the workflow, just report the status as failure
            // This allows the workflow to continue and report results
            console.log('Setting test status to failure but allowing workflow to continue');
          }
          
    - name: Validate and Report Test Completion
      run: |
        echo "----------------------------------------"
        echo "Integration Test Results"
        echo "----------------------------------------"
        echo "Status: ${{ steps.test_results.outputs.status }}"
        echo "Platform: ${{ inputs.platform }}"
        echo "Windsor Up Used: ${{ inputs.windsor_up }}"
        echo "----------------------------------------"
      shell: bash
    